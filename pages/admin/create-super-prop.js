import React, { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { useModal } from "../../contexts/ModalContext";
import EventSelector from "../../components/EventSelector";

export default function CreateSuperPropPage() {
  const router = useRouter();
  const { openModal } = useModal();
  // Pre-fill Pack Title and Event from query parameters
  const { packTitle: initialPackTitle, eventId, eventTitle, eventTime, eventLeague } = router.query;
  // Remove manual propID; it's auto-generated by Airtable
  const [propShort, setPropShort] = useState("");
  const [propSummary, setPropSummary] = useState("");
  const [packTitle, setPackTitle] = useState("");
  const [sideCount, setSideCount] = useState(2);
  const [sideLabels, setSideLabels] = useState({});
  const [sideTakes, setSideTakes] = useState({});
  // Selected file for cover image
  const [selectedFile, setSelectedFile] = useState(null);
  // Selected existing event to link
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [csvError, setCSVError] = useState(null);

  // Update useEffect to initialize sideLabels and sideTakes
  useEffect(() => {
    const newLabels = {};
    const newTakes = {};
    for (let i = 0; i < sideCount; i++) {
      const letter = String.fromCharCode(65 + i);
      newLabels[letter] = sideLabels[letter] || "";
      newTakes[letter] = sideTakes[letter] || "";
    }
    setSideLabels(newLabels);
    setSideTakes(newTakes);
  }, [sideCount]);

  // Update useEffect to initialize packTitle and selectedEvent from query parameters
  useEffect(() => {
    if (initialPackTitle) {
      setPackTitle(initialPackTitle);
    }
    if (eventId) {
      setSelectedEvent({ id: eventId, eventTitle, eventTime, eventLeague });
    }
  }, [initialPackTitle, eventId, eventTitle, eventTime, eventLeague]);

  const handleLabelChange = (letter, value) => {
    setSideLabels(prev => ({ ...prev, [letter]: value }));
  };

  // Add handler for take inputs
  const handleTakeChange = (letter, value) => {
    setSideTakes(prev => ({ ...prev, [letter]: value }));
  };
  // Handle CSV upload to auto-fill form fields
  const handleCSVUpload = (e) => {
    setCSVError(null);
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const text = reader.result;
        // Split into non-empty lines (header + one row)
        const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
        if (lines.length < 2) throw new Error('Invalid CSV');
        const headers = parseCSVLine(lines[0]).map(h => h.trim());
        const values = parseCSVLine(lines[1]).map(v => v.trim());
        const data = {};
        headers.forEach((h, i) => { data[h] = values[i] || ''; });
        // Support headers with or without spaces
        if (data['PackTitle'] || data['Pack Title']) setPackTitle(data['PackTitle'] || data['Pack Title']);
        if (data['ShortTitle'] || data['Short Title']) setPropShort(data['ShortTitle'] || data['Short Title']);
        if (data['Summary']) setPropSummary(data['Summary']);
        const newLabels = {};
        const newTakes = {};
        let maxSide = 0;
        ['A','B','C','D','E','F','G','H'].forEach((letter, idx) => {
          const shortKey = `PropSide${letter}Short`;
          const takeKey = `PropSide${letter}Take`;
          const shortVal = data[shortKey];
          if (shortVal) {
            newLabels[letter] = shortVal;
            newTakes[letter] = data[takeKey] || '';
            maxSide = idx + 1;
          }
        });
        setSideCount(Math.max(Math.min(maxSide || 2, 8), 2));
        setSideLabels(prev => ({ ...prev, ...newLabels }));
        setSideTakes(prev => ({ ...prev, ...newTakes }));
      } catch {
        setCSVError('Failed to parse CSV');
      }
    };
    reader.onerror = () => setCSVError('Failed to read CSV');
    reader.readAsText(file);
  };

  // CSV parser that handles quoted fields with commas
  const parseCSVLine = (line) => {
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        if (inQuotes && line[i+1] === '"') {
          current += '"';
          i += 1;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (char === ',' && !inQuotes) {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current);
    return result;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    // Prepare cover upload and payload
    // Upload cover if selected
    let propCoverURL;
    // Declare packCoverURL for pack-level cover
    let packCoverURL;
    if (selectedFile) {
      // Read file as base64
      const fileData = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(selectedFile);
      });
      const filename = `${Date.now()}-${selectedFile.name}`;
      const uploadRes = await fetch("/api/admin/uploadPropCover", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ filename, fileData }),
      });
      const uploadData = await uploadRes.json();
      if (!uploadData.success) throw new Error(uploadData.error || "Cover upload failed");
      propCoverURL = uploadData.url;
      // Upload the same file as pack cover
      const uploadPackRes = await fetch("/api/admin/uploadPackCover", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ filename, fileData }),
      });
      const uploadPackData = await uploadPackRes.json();
      if (!uploadPackData.success) throw new Error(uploadPackData.error || "Cover upload failed");
      packCoverURL = uploadPackData.url;
    }
    // Build payload including event fields
    const payload = {
      packTitle,
      propShort,
      propSummary,
      sideCount,
      // Event fields - either link existing or create new
      ...(selectedEvent ? {
        eventId: selectedEvent.id,
        eventTitle: selectedEvent.eventTitle,
        eventTime: selectedEvent.eventTime,
        eventLeague: selectedEvent.eventLeague
      } : {}),
      // Include uploaded cover URL for prop
      ...(propCoverURL && { propCoverURL, propCoverStatus: "generated" }),
      // Include pack-level cover URL
      ...(packCoverURL && { packCoverUrl: packCoverURL }),
      // Short labels
      ...Object.fromEntries(
        Object.entries(sideLabels).map(([letter, label]) => ([`PropSide${letter}Short`, label]))
      ),
      // Take labels
      ...Object.fromEntries(
        Object.entries(sideTakes).map(([letter, take]) => ([`PropSide${letter}Take`, take]))
      ),
    };

    try {
      const res = await fetch("/api/admin/create-super-prop", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      const data = await res.json();
      if (data.success) {
        const newPropID = data.record.fields.propID;
        const url = `${window.location.origin}/props/${newPropID}`;
        openModal("superPropCreated", { url, onDone: () => router.push("/admin") });
      } else {
        setError(data.error || "Failed to create super prop");
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="p-4 max-w-4xl mx-auto">
      <h1 className="text-2xl font-bold mb-4">Create a Super Prop</h1>
      <div>
        <label htmlFor="csvUpload" className="block text-sm font-medium text-gray-700">Upload CSV</label>
        <input
          id="csvUpload"
          type="file"
          accept=".csv,text/csv"
          onChange={handleCSVUpload}
          className="mt-1 block w-full text-sm text-gray-600"
        />
        {csvError && <p className="text-red-600 text-sm mt-1">{csvError}</p>}
      </div>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="packTitle" className="block text-sm font-medium text-gray-700">Pack Title</label>
          <input
            id="packTitle"
            type="text"
            value={packTitle}
            onChange={e => setPackTitle(e.target.value)}
            className="mt-1 block w-full border rounded px-2 py-1"
          />
        </div>
        <div>
          <label htmlFor="propShort" className="block text-sm font-medium text-gray-700">Short Title</label>
          <input
            id="propShort"
            type="text"
            value={propShort}
            onChange={e => setPropShort(e.target.value)}
            className="mt-1 block w-full border rounded px-2 py-1"
          />
        </div>

        <div>
          <label htmlFor="propSummary" className="block text-sm font-medium text-gray-700">Summary</label>
          <textarea
            id="propSummary"
            value={propSummary}
            onChange={e => setPropSummary(e.target.value)}
            className="mt-1 block w-full border rounded px-2 py-1"
            rows={3}
          />
        </div>
        {/* Event Association */}
        <div>
          <label className="block text-sm font-medium text-gray-700">Event</label>
          <EventSelector
            selectedEvent={selectedEvent}
            onSelect={(evt) => setSelectedEvent(evt)}
          />
          {selectedEvent && (
            <p className="mt-2 text-sm text-gray-700">
              Selected: {selectedEvent.eventTitle} — {new Date(selectedEvent.eventTime).toLocaleString()}
            </p>
          )}
        </div>
        {/* Cover Image Upload */}
        <div>
          <label htmlFor="propCover" className="block text-sm font-medium text-gray-700">Cover Image</label>
          <input
            id="propCover"
            type="file"
            accept="image/*"
            onChange={e => setSelectedFile(e.target.files?.[0] || null)}
            className="mt-1 block w-full text-sm text-gray-600"
          />
        </div>

        <div>
          <label htmlFor="sideCount" className="block text-sm font-medium text-gray-700">
            Number of Options (2–8)
          </label>
          <input
            id="sideCount"
            type="number"
            min={2}
            max={8}
            value={sideCount}
            onChange={e => setSideCount(Math.min(Math.max(Number(e.target.value), 2), 8))}
            className="mt-1 block w-24 border rounded px-2 py-1"
          />
        </div>

        {Array.from({ length: sideCount }).map((_, i) => {
          const letter = String.fromCharCode(65 + i);
          return (
            <fieldset key={letter} className="border p-4 rounded-lg mb-4">
              <legend className="text-lg font-semibold mb-2">Side {letter}</legend>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <div>
                  <label htmlFor={`PropSide${letter}Short`} className="block text-sm font-medium text-gray-700">
                    Short Label
                  </label>
                  <input
                    id={`PropSide${letter}Short`}
                    type="text"
                    value={sideLabels[letter] || ""}
                    onChange={e => handleLabelChange(letter, e.target.value)}
                    className="mt-1 block w-full border rounded px-2 py-1"
                  />
                </div>
                <div>
                  <label htmlFor={`PropSide${letter}Take`} className="block text-sm font-medium text-gray-700">
                    Take Label
                  </label>
                  <input
                    id={`PropSide${letter}Take`}
                    type="text"
                    value={sideTakes[letter] || ""}
                    onChange={e => handleTakeChange(letter, e.target.value)}
                    className="mt-1 block w-full border rounded px-2 py-1"
                  />
                </div>
              </div>
            </fieldset>
          );
        })}

        {error && <p className="text-red-600">{error}</p>}

        <button
          type="submit"
          disabled={loading}
          className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
        >
          {loading ? "Creating..." : "Create Super Prop"}
        </button>
      </form>
    </div>
  );
} 